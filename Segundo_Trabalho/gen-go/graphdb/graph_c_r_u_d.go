// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package graphdb

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

type GraphCRUD interface {
	// Parameters:
	//  - Vertex
	CreateVertex(vertex *GraphVertex) (err error)
	// Parameters:
	//  - Name
	ReadVertex(name Int) (r *GraphVertex, err error)
	// Parameters:
	//  - Name
	DeleteVertex(name Int) (err error)
	// Parameters:
	//  - Vertex
	UpdateVertex(vertex *GraphVertex) (err error)
	// Parameters:
	//  - Edge
	CreateEdge(edge *GraphEdge) (err error)
	// Parameters:
	//  - FirstVertex
	//  - SecondVertex
	ReadEdge(firstVertex Int, secondVertex Int) (r *GraphEdge, err error)
	// Parameters:
	//  - Edge
	DeleteEdge(edge *GraphEdge) (err error)
	// Parameters:
	//  - Edge
	UpdateEdge(edge *GraphEdge) (err error)
	// Parameters:
	//  - Name
	FindEdgesOfVertex(name Int) (r []*GraphEdge, err error)
	// Parameters:
	//  - Name
	FindNeighbours(name Int) (r []*GraphVertex, err error)
	// Parameters:
	//  - Name
	DeleteEdgesOfVertex(name Int) (err error)
	// Parameters:
	//  - Edge
	DeleteEdgeColateral(edge *GraphEdge) (err error)
	// Parameters:
	//  - Edge
	UpdateEdgeColateral(edge *GraphEdge) (err error)
	// Parameters:
	//  - Name
	FindNeighboursRemote(name Int) (r []*GraphVertex, err error)
	GetGraph() (r *Graph, err error)
	// Parameters:
	//  - Source
	//  - Target
	ShortestPath(source Int, target Int) (r float64, err error)
}

type GraphCRUDClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewGraphCRUDClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *GraphCRUDClient {
	return &GraphCRUDClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewGraphCRUDClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *GraphCRUDClient {
	return &GraphCRUDClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - Vertex
func (p *GraphCRUDClient) CreateVertex(vertex *GraphVertex) (err error) {
	if err = p.sendCreateVertex(vertex); err != nil {
		return
	}
	return p.recvCreateVertex()
}

func (p *GraphCRUDClient) sendCreateVertex(vertex *GraphVertex) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("createVertex", thrift.CALL, p.SeqId)
	args2 := NewCreateVertexArgs()
	args2.Vertex = vertex
	err = args2.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvCreateVertex() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error4 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error5 error
		error5, err = error4.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error5
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result3 := NewCreateVertexResult()
	err = result3.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Name
func (p *GraphCRUDClient) ReadVertex(name Int) (r *GraphVertex, err error) {
	if err = p.sendReadVertex(name); err != nil {
		return
	}
	return p.recvReadVertex()
}

func (p *GraphCRUDClient) sendReadVertex(name Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("readVertex", thrift.CALL, p.SeqId)
	args6 := NewReadVertexArgs()
	args6.Name = name
	err = args6.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvReadVertex() (value *GraphVertex, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error8 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error9 error
		error9, err = error8.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error9
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result7 := NewReadVertexResult()
	err = result7.Read(iprot)
	iprot.ReadMessageEnd()
	value = result7.Success
	return
}

// Parameters:
//  - Name
func (p *GraphCRUDClient) DeleteVertex(name Int) (err error) {
	if err = p.sendDeleteVertex(name); err != nil {
		return
	}
	return p.recvDeleteVertex()
}

func (p *GraphCRUDClient) sendDeleteVertex(name Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteVertex", thrift.CALL, p.SeqId)
	args10 := NewDeleteVertexArgs()
	args10.Name = name
	err = args10.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvDeleteVertex() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error12 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error13 error
		error13, err = error12.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error13
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result11 := NewDeleteVertexResult()
	err = result11.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Vertex
func (p *GraphCRUDClient) UpdateVertex(vertex *GraphVertex) (err error) {
	if err = p.sendUpdateVertex(vertex); err != nil {
		return
	}
	return p.recvUpdateVertex()
}

func (p *GraphCRUDClient) sendUpdateVertex(vertex *GraphVertex) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("updateVertex", thrift.CALL, p.SeqId)
	args14 := NewUpdateVertexArgs()
	args14.Vertex = vertex
	err = args14.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvUpdateVertex() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error16 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error17 error
		error17, err = error16.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error17
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result15 := NewUpdateVertexResult()
	err = result15.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Edge
func (p *GraphCRUDClient) CreateEdge(edge *GraphEdge) (err error) {
	if err = p.sendCreateEdge(edge); err != nil {
		return
	}
	return p.recvCreateEdge()
}

func (p *GraphCRUDClient) sendCreateEdge(edge *GraphEdge) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("createEdge", thrift.CALL, p.SeqId)
	args18 := NewCreateEdgeArgs()
	args18.Edge = edge
	err = args18.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvCreateEdge() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error20 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error21 error
		error21, err = error20.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error21
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result19 := NewCreateEdgeResult()
	err = result19.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - FirstVertex
//  - SecondVertex
func (p *GraphCRUDClient) ReadEdge(firstVertex Int, secondVertex Int) (r *GraphEdge, err error) {
	if err = p.sendReadEdge(firstVertex, secondVertex); err != nil {
		return
	}
	return p.recvReadEdge()
}

func (p *GraphCRUDClient) sendReadEdge(firstVertex Int, secondVertex Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("readEdge", thrift.CALL, p.SeqId)
	args22 := NewReadEdgeArgs()
	args22.FirstVertex = firstVertex
	args22.SecondVertex = secondVertex
	err = args22.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvReadEdge() (value *GraphEdge, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result23 := NewReadEdgeResult()
	err = result23.Read(iprot)
	iprot.ReadMessageEnd()
	value = result23.Success
	return
}

// Parameters:
//  - Edge
func (p *GraphCRUDClient) DeleteEdge(edge *GraphEdge) (err error) {
	if err = p.sendDeleteEdge(edge); err != nil {
		return
	}
	return p.recvDeleteEdge()
}

func (p *GraphCRUDClient) sendDeleteEdge(edge *GraphEdge) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteEdge", thrift.CALL, p.SeqId)
	args26 := NewDeleteEdgeArgs()
	args26.Edge = edge
	err = args26.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvDeleteEdge() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result27 := NewDeleteEdgeResult()
	err = result27.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Edge
func (p *GraphCRUDClient) UpdateEdge(edge *GraphEdge) (err error) {
	if err = p.sendUpdateEdge(edge); err != nil {
		return
	}
	return p.recvUpdateEdge()
}

func (p *GraphCRUDClient) sendUpdateEdge(edge *GraphEdge) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("updateEdge", thrift.CALL, p.SeqId)
	args30 := NewUpdateEdgeArgs()
	args30.Edge = edge
	err = args30.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvUpdateEdge() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result31 := NewUpdateEdgeResult()
	err = result31.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Name
func (p *GraphCRUDClient) FindEdgesOfVertex(name Int) (r []*GraphEdge, err error) {
	if err = p.sendFindEdgesOfVertex(name); err != nil {
		return
	}
	return p.recvFindEdgesOfVertex()
}

func (p *GraphCRUDClient) sendFindEdgesOfVertex(name Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("findEdgesOfVertex", thrift.CALL, p.SeqId)
	args34 := NewFindEdgesOfVertexArgs()
	args34.Name = name
	err = args34.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvFindEdgesOfVertex() (value []*GraphEdge, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result35 := NewFindEdgesOfVertexResult()
	err = result35.Read(iprot)
	iprot.ReadMessageEnd()
	value = result35.Success
	return
}

// Parameters:
//  - Name
func (p *GraphCRUDClient) FindNeighbours(name Int) (r []*GraphVertex, err error) {
	if err = p.sendFindNeighbours(name); err != nil {
		return
	}
	return p.recvFindNeighbours()
}

func (p *GraphCRUDClient) sendFindNeighbours(name Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("findNeighbours", thrift.CALL, p.SeqId)
	args38 := NewFindNeighboursArgs()
	args38.Name = name
	err = args38.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvFindNeighbours() (value []*GraphVertex, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result39 := NewFindNeighboursResult()
	err = result39.Read(iprot)
	iprot.ReadMessageEnd()
	value = result39.Success
	return
}

// Parameters:
//  - Name
func (p *GraphCRUDClient) DeleteEdgesOfVertex(name Int) (err error) {
	if err = p.sendDeleteEdgesOfVertex(name); err != nil {
		return
	}
	return p.recvDeleteEdgesOfVertex()
}

func (p *GraphCRUDClient) sendDeleteEdgesOfVertex(name Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteEdgesOfVertex", thrift.CALL, p.SeqId)
	args42 := NewDeleteEdgesOfVertexArgs()
	args42.Name = name
	err = args42.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvDeleteEdgesOfVertex() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result43 := NewDeleteEdgesOfVertexResult()
	err = result43.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Edge
func (p *GraphCRUDClient) DeleteEdgeColateral(edge *GraphEdge) (err error) {
	if err = p.sendDeleteEdgeColateral(edge); err != nil {
		return
	}
	return p.recvDeleteEdgeColateral()
}

func (p *GraphCRUDClient) sendDeleteEdgeColateral(edge *GraphEdge) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteEdgeColateral", thrift.CALL, p.SeqId)
	args46 := NewDeleteEdgeColateralArgs()
	args46.Edge = edge
	err = args46.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvDeleteEdgeColateral() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result47 := NewDeleteEdgeColateralResult()
	err = result47.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Edge
func (p *GraphCRUDClient) UpdateEdgeColateral(edge *GraphEdge) (err error) {
	if err = p.sendUpdateEdgeColateral(edge); err != nil {
		return
	}
	return p.recvUpdateEdgeColateral()
}

func (p *GraphCRUDClient) sendUpdateEdgeColateral(edge *GraphEdge) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("updateEdgeColateral", thrift.CALL, p.SeqId)
	args50 := NewUpdateEdgeColateralArgs()
	args50.Edge = edge
	err = args50.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvUpdateEdgeColateral() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error52 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error53 error
		error53, err = error52.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error53
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result51 := NewUpdateEdgeColateralResult()
	err = result51.Read(iprot)
	iprot.ReadMessageEnd()
	return
}

// Parameters:
//  - Name
func (p *GraphCRUDClient) FindNeighboursRemote(name Int) (r []*GraphVertex, err error) {
	if err = p.sendFindNeighboursRemote(name); err != nil {
		return
	}
	return p.recvFindNeighboursRemote()
}

func (p *GraphCRUDClient) sendFindNeighboursRemote(name Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("findNeighboursRemote", thrift.CALL, p.SeqId)
	args54 := NewFindNeighboursRemoteArgs()
	args54.Name = name
	err = args54.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvFindNeighboursRemote() (value []*GraphVertex, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error56 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error57 error
		error57, err = error56.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error57
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result55 := NewFindNeighboursRemoteResult()
	err = result55.Read(iprot)
	iprot.ReadMessageEnd()
	value = result55.Success
	return
}

func (p *GraphCRUDClient) GetGraph() (r *Graph, err error) {
	if err = p.sendGetGraph(); err != nil {
		return
	}
	return p.recvGetGraph()
}

func (p *GraphCRUDClient) sendGetGraph() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getGraph", thrift.CALL, p.SeqId)
	args58 := NewGetGraphArgs()
	err = args58.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvGetGraph() (value *Graph, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error60 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error61 error
		error61, err = error60.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error61
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result59 := NewGetGraphResult()
	err = result59.Read(iprot)
	iprot.ReadMessageEnd()
	value = result59.Success
	return
}

// Parameters:
//  - Source
//  - Target
func (p *GraphCRUDClient) ShortestPath(source Int, target Int) (r float64, err error) {
	if err = p.sendShortestPath(source, target); err != nil {
		return
	}
	return p.recvShortestPath()
}

func (p *GraphCRUDClient) sendShortestPath(source Int, target Int) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("shortestPath", thrift.CALL, p.SeqId)
	args62 := NewShortestPathArgs()
	args62.Source = source
	args62.Target = target
	err = args62.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *GraphCRUDClient) recvShortestPath() (value float64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error64 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error65 error
		error65, err = error64.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error65
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result63 := NewShortestPathResult()
	err = result63.Read(iprot)
	iprot.ReadMessageEnd()
	value = result63.Success
	return
}

type GraphCRUDProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      GraphCRUD
}

func (p *GraphCRUDProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *GraphCRUDProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *GraphCRUDProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewGraphCRUDProcessor(handler GraphCRUD) *GraphCRUDProcessor {

	self66 := &GraphCRUDProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self66.processorMap["createVertex"] = &graphCRUDProcessorCreateVertex{handler: handler}
	self66.processorMap["readVertex"] = &graphCRUDProcessorReadVertex{handler: handler}
	self66.processorMap["deleteVertex"] = &graphCRUDProcessorDeleteVertex{handler: handler}
	self66.processorMap["updateVertex"] = &graphCRUDProcessorUpdateVertex{handler: handler}
	self66.processorMap["createEdge"] = &graphCRUDProcessorCreateEdge{handler: handler}
	self66.processorMap["readEdge"] = &graphCRUDProcessorReadEdge{handler: handler}
	self66.processorMap["deleteEdge"] = &graphCRUDProcessorDeleteEdge{handler: handler}
	self66.processorMap["updateEdge"] = &graphCRUDProcessorUpdateEdge{handler: handler}
	self66.processorMap["findEdgesOfVertex"] = &graphCRUDProcessorFindEdgesOfVertex{handler: handler}
	self66.processorMap["findNeighbours"] = &graphCRUDProcessorFindNeighbours{handler: handler}
	self66.processorMap["deleteEdgesOfVertex"] = &graphCRUDProcessorDeleteEdgesOfVertex{handler: handler}
	self66.processorMap["deleteEdgeColateral"] = &graphCRUDProcessorDeleteEdgeColateral{handler: handler}
	self66.processorMap["updateEdgeColateral"] = &graphCRUDProcessorUpdateEdgeColateral{handler: handler}
	self66.processorMap["findNeighboursRemote"] = &graphCRUDProcessorFindNeighboursRemote{handler: handler}
	self66.processorMap["getGraph"] = &graphCRUDProcessorGetGraph{handler: handler}
	self66.processorMap["shortestPath"] = &graphCRUDProcessorShortestPath{handler: handler}
	return self66
}

func (p *GraphCRUDProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x67 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x67.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x67

}

type graphCRUDProcessorCreateVertex struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorCreateVertex) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateVertexArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCreateVertexResult()
	if err = p.handler.CreateVertex(args.Vertex); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createVertex: "+err.Error())
		oprot.WriteMessageBegin("createVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("createVertex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorReadVertex struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorReadVertex) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewReadVertexArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("readVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewReadVertexResult()
	if result.Success, err = p.handler.ReadVertex(args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing readVertex: "+err.Error())
		oprot.WriteMessageBegin("readVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("readVertex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorDeleteVertex struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorDeleteVertex) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteVertexArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteVertexResult()
	if err = p.handler.DeleteVertex(args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteVertex: "+err.Error())
		oprot.WriteMessageBegin("deleteVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteVertex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorUpdateVertex struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorUpdateVertex) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewUpdateVertexArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("updateVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewUpdateVertexResult()
	if err = p.handler.UpdateVertex(args.Vertex); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateVertex: "+err.Error())
		oprot.WriteMessageBegin("updateVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("updateVertex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorCreateEdge struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorCreateEdge) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateEdgeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCreateEdgeResult()
	if err = p.handler.CreateEdge(args.Edge); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createEdge: "+err.Error())
		oprot.WriteMessageBegin("createEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("createEdge", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorReadEdge struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorReadEdge) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewReadEdgeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("readEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewReadEdgeResult()
	if result.Success, err = p.handler.ReadEdge(args.FirstVertex, args.SecondVertex); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing readEdge: "+err.Error())
		oprot.WriteMessageBegin("readEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("readEdge", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorDeleteEdge struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorDeleteEdge) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteEdgeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteEdgeResult()
	if err = p.handler.DeleteEdge(args.Edge); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteEdge: "+err.Error())
		oprot.WriteMessageBegin("deleteEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteEdge", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorUpdateEdge struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorUpdateEdge) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewUpdateEdgeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("updateEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewUpdateEdgeResult()
	if err = p.handler.UpdateEdge(args.Edge); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateEdge: "+err.Error())
		oprot.WriteMessageBegin("updateEdge", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("updateEdge", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorFindEdgesOfVertex struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorFindEdgesOfVertex) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFindEdgesOfVertexArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("findEdgesOfVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFindEdgesOfVertexResult()
	if result.Success, err = p.handler.FindEdgesOfVertex(args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findEdgesOfVertex: "+err.Error())
		oprot.WriteMessageBegin("findEdgesOfVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("findEdgesOfVertex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorFindNeighbours struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorFindNeighbours) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFindNeighboursArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("findNeighbours", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFindNeighboursResult()
	if result.Success, err = p.handler.FindNeighbours(args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNeighbours: "+err.Error())
		oprot.WriteMessageBegin("findNeighbours", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("findNeighbours", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorDeleteEdgesOfVertex struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorDeleteEdgesOfVertex) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteEdgesOfVertexArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteEdgesOfVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteEdgesOfVertexResult()
	if err = p.handler.DeleteEdgesOfVertex(args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteEdgesOfVertex: "+err.Error())
		oprot.WriteMessageBegin("deleteEdgesOfVertex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteEdgesOfVertex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorDeleteEdgeColateral struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorDeleteEdgeColateral) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteEdgeColateralArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteEdgeColateral", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteEdgeColateralResult()
	if err = p.handler.DeleteEdgeColateral(args.Edge); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteEdgeColateral: "+err.Error())
		oprot.WriteMessageBegin("deleteEdgeColateral", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteEdgeColateral", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorUpdateEdgeColateral struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorUpdateEdgeColateral) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewUpdateEdgeColateralArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("updateEdgeColateral", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewUpdateEdgeColateralResult()
	if err = p.handler.UpdateEdgeColateral(args.Edge); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateEdgeColateral: "+err.Error())
		oprot.WriteMessageBegin("updateEdgeColateral", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("updateEdgeColateral", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorFindNeighboursRemote struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorFindNeighboursRemote) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFindNeighboursRemoteArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("findNeighboursRemote", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFindNeighboursRemoteResult()
	if result.Success, err = p.handler.FindNeighboursRemote(args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNeighboursRemote: "+err.Error())
		oprot.WriteMessageBegin("findNeighboursRemote", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("findNeighboursRemote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorGetGraph struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorGetGraph) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetGraphArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getGraph", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetGraphResult()
	if result.Success, err = p.handler.GetGraph(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getGraph: "+err.Error())
		oprot.WriteMessageBegin("getGraph", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getGraph", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type graphCRUDProcessorShortestPath struct {
	handler GraphCRUD
}

func (p *graphCRUDProcessorShortestPath) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewShortestPathArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("shortestPath", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewShortestPathResult()
	if result.Success, err = p.handler.ShortestPath(args.Source, args.Target); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shortestPath: "+err.Error())
		oprot.WriteMessageBegin("shortestPath", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("shortestPath", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type CreateVertexArgs struct {
	Vertex *GraphVertex `thrift:"vertex,1"`
}

func NewCreateVertexArgs() *CreateVertexArgs {
	return &CreateVertexArgs{}
}

func (p *CreateVertexArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateVertexArgs) readField1(iprot thrift.TProtocol) error {
	p.Vertex = NewGraphVertex()
	if err := p.Vertex.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Vertex)
	}
	return nil
}

func (p *CreateVertexArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createVertex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateVertexArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Vertex != nil {
		if err := oprot.WriteFieldBegin("vertex", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:vertex: %s", p, err)
		}
		if err := p.Vertex.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Vertex)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:vertex: %s", p, err)
		}
	}
	return err
}

func (p *CreateVertexArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateVertexArgs(%+v)", *p)
}

type CreateVertexResult struct {
}

func NewCreateVertexResult() *CreateVertexResult {
	return &CreateVertexResult{}
}

func (p *CreateVertexResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateVertexResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createVertex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateVertexResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateVertexResult(%+v)", *p)
}

type ReadVertexArgs struct {
	Name Int `thrift:"name,1"`
}

func NewReadVertexArgs() *ReadVertexArgs {
	return &ReadVertexArgs{}
}

func (p *ReadVertexArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ReadVertexArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = Int(v)
	}
	return nil
}

func (p *ReadVertexArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("readVertex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ReadVertexArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *ReadVertexArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadVertexArgs(%+v)", *p)
}

type ReadVertexResult struct {
	Success *GraphVertex `thrift:"success,0"`
}

func NewReadVertexResult() *ReadVertexResult {
	return &ReadVertexResult{}
}

func (p *ReadVertexResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ReadVertexResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewGraphVertex()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *ReadVertexResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("readVertex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ReadVertexResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ReadVertexResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadVertexResult(%+v)", *p)
}

type DeleteVertexArgs struct {
	Name Int `thrift:"name,1"`
}

func NewDeleteVertexArgs() *DeleteVertexArgs {
	return &DeleteVertexArgs{}
}

func (p *DeleteVertexArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteVertexArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = Int(v)
	}
	return nil
}

func (p *DeleteVertexArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteVertex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteVertexArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *DeleteVertexArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteVertexArgs(%+v)", *p)
}

type DeleteVertexResult struct {
}

func NewDeleteVertexResult() *DeleteVertexResult {
	return &DeleteVertexResult{}
}

func (p *DeleteVertexResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteVertexResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteVertex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteVertexResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteVertexResult(%+v)", *p)
}

type UpdateVertexArgs struct {
	Vertex *GraphVertex `thrift:"vertex,1"`
}

func NewUpdateVertexArgs() *UpdateVertexArgs {
	return &UpdateVertexArgs{}
}

func (p *UpdateVertexArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateVertexArgs) readField1(iprot thrift.TProtocol) error {
	p.Vertex = NewGraphVertex()
	if err := p.Vertex.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Vertex)
	}
	return nil
}

func (p *UpdateVertexArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateVertex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateVertexArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Vertex != nil {
		if err := oprot.WriteFieldBegin("vertex", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:vertex: %s", p, err)
		}
		if err := p.Vertex.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Vertex)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:vertex: %s", p, err)
		}
	}
	return err
}

func (p *UpdateVertexArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateVertexArgs(%+v)", *p)
}

type UpdateVertexResult struct {
}

func NewUpdateVertexResult() *UpdateVertexResult {
	return &UpdateVertexResult{}
}

func (p *UpdateVertexResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateVertexResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateVertex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateVertexResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateVertexResult(%+v)", *p)
}

type CreateEdgeArgs struct {
	Edge *GraphEdge `thrift:"edge,1"`
}

func NewCreateEdgeArgs() *CreateEdgeArgs {
	return &CreateEdgeArgs{}
}

func (p *CreateEdgeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateEdgeArgs) readField1(iprot thrift.TProtocol) error {
	p.Edge = NewGraphEdge()
	if err := p.Edge.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Edge)
	}
	return nil
}

func (p *CreateEdgeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createEdge_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateEdgeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Edge != nil {
		if err := oprot.WriteFieldBegin("edge", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:edge: %s", p, err)
		}
		if err := p.Edge.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Edge)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:edge: %s", p, err)
		}
	}
	return err
}

func (p *CreateEdgeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateEdgeArgs(%+v)", *p)
}

type CreateEdgeResult struct {
}

func NewCreateEdgeResult() *CreateEdgeResult {
	return &CreateEdgeResult{}
}

func (p *CreateEdgeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateEdgeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createEdge_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateEdgeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateEdgeResult(%+v)", *p)
}

type ReadEdgeArgs struct {
	FirstVertex  Int `thrift:"firstVertex,1"`
	SecondVertex Int `thrift:"secondVertex,2"`
}

func NewReadEdgeArgs() *ReadEdgeArgs {
	return &ReadEdgeArgs{}
}

func (p *ReadEdgeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ReadEdgeArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.FirstVertex = Int(v)
	}
	return nil
}

func (p *ReadEdgeArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.SecondVertex = Int(v)
	}
	return nil
}

func (p *ReadEdgeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("readEdge_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ReadEdgeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("firstVertex", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:firstVertex: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.FirstVertex)); err != nil {
		return fmt.Errorf("%T.firstVertex (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:firstVertex: %s", p, err)
	}
	return err
}

func (p *ReadEdgeArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("secondVertex", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:secondVertex: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.SecondVertex)); err != nil {
		return fmt.Errorf("%T.secondVertex (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:secondVertex: %s", p, err)
	}
	return err
}

func (p *ReadEdgeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadEdgeArgs(%+v)", *p)
}

type ReadEdgeResult struct {
	Success *GraphEdge `thrift:"success,0"`
}

func NewReadEdgeResult() *ReadEdgeResult {
	return &ReadEdgeResult{}
}

func (p *ReadEdgeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ReadEdgeResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewGraphEdge()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *ReadEdgeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("readEdge_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ReadEdgeResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ReadEdgeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadEdgeResult(%+v)", *p)
}

type DeleteEdgeArgs struct {
	Edge *GraphEdge `thrift:"edge,1"`
}

func NewDeleteEdgeArgs() *DeleteEdgeArgs {
	return &DeleteEdgeArgs{}
}

func (p *DeleteEdgeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteEdgeArgs) readField1(iprot thrift.TProtocol) error {
	p.Edge = NewGraphEdge()
	if err := p.Edge.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Edge)
	}
	return nil
}

func (p *DeleteEdgeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteEdge_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteEdgeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Edge != nil {
		if err := oprot.WriteFieldBegin("edge", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:edge: %s", p, err)
		}
		if err := p.Edge.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Edge)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:edge: %s", p, err)
		}
	}
	return err
}

func (p *DeleteEdgeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteEdgeArgs(%+v)", *p)
}

type DeleteEdgeResult struct {
}

func NewDeleteEdgeResult() *DeleteEdgeResult {
	return &DeleteEdgeResult{}
}

func (p *DeleteEdgeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteEdgeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteEdge_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteEdgeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteEdgeResult(%+v)", *p)
}

type UpdateEdgeArgs struct {
	Edge *GraphEdge `thrift:"edge,1"`
}

func NewUpdateEdgeArgs() *UpdateEdgeArgs {
	return &UpdateEdgeArgs{}
}

func (p *UpdateEdgeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateEdgeArgs) readField1(iprot thrift.TProtocol) error {
	p.Edge = NewGraphEdge()
	if err := p.Edge.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Edge)
	}
	return nil
}

func (p *UpdateEdgeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateEdge_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateEdgeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Edge != nil {
		if err := oprot.WriteFieldBegin("edge", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:edge: %s", p, err)
		}
		if err := p.Edge.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Edge)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:edge: %s", p, err)
		}
	}
	return err
}

func (p *UpdateEdgeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateEdgeArgs(%+v)", *p)
}

type UpdateEdgeResult struct {
}

func NewUpdateEdgeResult() *UpdateEdgeResult {
	return &UpdateEdgeResult{}
}

func (p *UpdateEdgeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateEdgeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateEdge_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateEdgeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateEdgeResult(%+v)", *p)
}

type FindEdgesOfVertexArgs struct {
	Name Int `thrift:"name,1"`
}

func NewFindEdgesOfVertexArgs() *FindEdgesOfVertexArgs {
	return &FindEdgesOfVertexArgs{}
}

func (p *FindEdgesOfVertexArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindEdgesOfVertexArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = Int(v)
	}
	return nil
}

func (p *FindEdgesOfVertexArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("findEdgesOfVertex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindEdgesOfVertexArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *FindEdgesOfVertexArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindEdgesOfVertexArgs(%+v)", *p)
}

type FindEdgesOfVertexResult struct {
	Success []*GraphEdge `thrift:"success,0"`
}

func NewFindEdgesOfVertexResult() *FindEdgesOfVertexResult {
	return &FindEdgesOfVertexResult{}
}

func (p *FindEdgesOfVertexResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindEdgesOfVertexResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*GraphEdge, 0, size)
	for i := 0; i < size; i++ {
		_elem68 := NewGraphEdge()
		if err := _elem68.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem68)
		}
		p.Success = append(p.Success, _elem68)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *FindEdgesOfVertexResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("findEdgesOfVertex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindEdgesOfVertexResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindEdgesOfVertexResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindEdgesOfVertexResult(%+v)", *p)
}

type FindNeighboursArgs struct {
	Name Int `thrift:"name,1"`
}

func NewFindNeighboursArgs() *FindNeighboursArgs {
	return &FindNeighboursArgs{}
}

func (p *FindNeighboursArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNeighboursArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = Int(v)
	}
	return nil
}

func (p *FindNeighboursArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("findNeighbours_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNeighboursArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *FindNeighboursArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNeighboursArgs(%+v)", *p)
}

type FindNeighboursResult struct {
	Success []*GraphVertex `thrift:"success,0"`
}

func NewFindNeighboursResult() *FindNeighboursResult {
	return &FindNeighboursResult{}
}

func (p *FindNeighboursResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNeighboursResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*GraphVertex, 0, size)
	for i := 0; i < size; i++ {
		_elem69 := NewGraphVertex()
		if err := _elem69.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem69)
		}
		p.Success = append(p.Success, _elem69)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *FindNeighboursResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("findNeighbours_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNeighboursResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindNeighboursResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNeighboursResult(%+v)", *p)
}

type DeleteEdgesOfVertexArgs struct {
	Name Int `thrift:"name,1"`
}

func NewDeleteEdgesOfVertexArgs() *DeleteEdgesOfVertexArgs {
	return &DeleteEdgesOfVertexArgs{}
}

func (p *DeleteEdgesOfVertexArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteEdgesOfVertexArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = Int(v)
	}
	return nil
}

func (p *DeleteEdgesOfVertexArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteEdgesOfVertex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteEdgesOfVertexArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *DeleteEdgesOfVertexArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteEdgesOfVertexArgs(%+v)", *p)
}

type DeleteEdgesOfVertexResult struct {
}

func NewDeleteEdgesOfVertexResult() *DeleteEdgesOfVertexResult {
	return &DeleteEdgesOfVertexResult{}
}

func (p *DeleteEdgesOfVertexResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteEdgesOfVertexResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteEdgesOfVertex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteEdgesOfVertexResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteEdgesOfVertexResult(%+v)", *p)
}

type DeleteEdgeColateralArgs struct {
	Edge *GraphEdge `thrift:"edge,1"`
}

func NewDeleteEdgeColateralArgs() *DeleteEdgeColateralArgs {
	return &DeleteEdgeColateralArgs{}
}

func (p *DeleteEdgeColateralArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteEdgeColateralArgs) readField1(iprot thrift.TProtocol) error {
	p.Edge = NewGraphEdge()
	if err := p.Edge.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Edge)
	}
	return nil
}

func (p *DeleteEdgeColateralArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteEdgeColateral_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteEdgeColateralArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Edge != nil {
		if err := oprot.WriteFieldBegin("edge", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:edge: %s", p, err)
		}
		if err := p.Edge.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Edge)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:edge: %s", p, err)
		}
	}
	return err
}

func (p *DeleteEdgeColateralArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteEdgeColateralArgs(%+v)", *p)
}

type DeleteEdgeColateralResult struct {
}

func NewDeleteEdgeColateralResult() *DeleteEdgeColateralResult {
	return &DeleteEdgeColateralResult{}
}

func (p *DeleteEdgeColateralResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteEdgeColateralResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteEdgeColateral_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteEdgeColateralResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteEdgeColateralResult(%+v)", *p)
}

type UpdateEdgeColateralArgs struct {
	Edge *GraphEdge `thrift:"edge,1"`
}

func NewUpdateEdgeColateralArgs() *UpdateEdgeColateralArgs {
	return &UpdateEdgeColateralArgs{}
}

func (p *UpdateEdgeColateralArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateEdgeColateralArgs) readField1(iprot thrift.TProtocol) error {
	p.Edge = NewGraphEdge()
	if err := p.Edge.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Edge)
	}
	return nil
}

func (p *UpdateEdgeColateralArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateEdgeColateral_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateEdgeColateralArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Edge != nil {
		if err := oprot.WriteFieldBegin("edge", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:edge: %s", p, err)
		}
		if err := p.Edge.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Edge)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:edge: %s", p, err)
		}
	}
	return err
}

func (p *UpdateEdgeColateralArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateEdgeColateralArgs(%+v)", *p)
}

type UpdateEdgeColateralResult struct {
}

func NewUpdateEdgeColateralResult() *UpdateEdgeColateralResult {
	return &UpdateEdgeColateralResult{}
}

func (p *UpdateEdgeColateralResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateEdgeColateralResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateEdgeColateral_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateEdgeColateralResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateEdgeColateralResult(%+v)", *p)
}

type FindNeighboursRemoteArgs struct {
	Name Int `thrift:"name,1"`
}

func NewFindNeighboursRemoteArgs() *FindNeighboursRemoteArgs {
	return &FindNeighboursRemoteArgs{}
}

func (p *FindNeighboursRemoteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNeighboursRemoteArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = Int(v)
	}
	return nil
}

func (p *FindNeighboursRemoteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("findNeighboursRemote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNeighboursRemoteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *FindNeighboursRemoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNeighboursRemoteArgs(%+v)", *p)
}

type FindNeighboursRemoteResult struct {
	Success []*GraphVertex `thrift:"success,0"`
}

func NewFindNeighboursRemoteResult() *FindNeighboursRemoteResult {
	return &FindNeighboursRemoteResult{}
}

func (p *FindNeighboursRemoteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNeighboursRemoteResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*GraphVertex, 0, size)
	for i := 0; i < size; i++ {
		_elem70 := NewGraphVertex()
		if err := _elem70.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem70)
		}
		p.Success = append(p.Success, _elem70)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *FindNeighboursRemoteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("findNeighboursRemote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNeighboursRemoteResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindNeighboursRemoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNeighboursRemoteResult(%+v)", *p)
}

type GetGraphArgs struct {
}

func NewGetGraphArgs() *GetGraphArgs {
	return &GetGraphArgs{}
}

func (p *GetGraphArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGraphArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGraph_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGraphArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGraphArgs(%+v)", *p)
}

type GetGraphResult struct {
	Success *Graph `thrift:"success,0"`
}

func NewGetGraphResult() *GetGraphResult {
	return &GetGraphResult{}
}

func (p *GetGraphResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGraphResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewGraph()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetGraphResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getGraph_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGraphResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGraphResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGraphResult(%+v)", *p)
}

type ShortestPathArgs struct {
	Source Int `thrift:"source,1"`
	Target Int `thrift:"target,2"`
}

func NewShortestPathArgs() *ShortestPathArgs {
	return &ShortestPathArgs{}
}

func (p *ShortestPathArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ShortestPathArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Source = Int(v)
	}
	return nil
}

func (p *ShortestPathArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Target = Int(v)
	}
	return nil
}

func (p *ShortestPathArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shortestPath_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ShortestPathArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("source", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:source: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Source)); err != nil {
		return fmt.Errorf("%T.source (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:source: %s", p, err)
	}
	return err
}

func (p *ShortestPathArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("target", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:target: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Target)); err != nil {
		return fmt.Errorf("%T.target (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:target: %s", p, err)
	}
	return err
}

func (p *ShortestPathArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ShortestPathArgs(%+v)", *p)
}

type ShortestPathResult struct {
	Success float64 `thrift:"success,0"`
}

func NewShortestPathResult() *ShortestPathResult {
	return &ShortestPathResult{}
}

func (p *ShortestPathResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ShortestPathResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ShortestPathResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shortestPath_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ShortestPathResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.DOUBLE, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteDouble(float64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ShortestPathResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ShortestPathResult(%+v)", *p)
}
